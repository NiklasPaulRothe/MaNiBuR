Aufgabe 1;

a) 11 Fehler gefunden


// #include <stdio.h> - <> anstatt ""
#include "stdio.h"

// Semicolon darf hier nicht stehen. define ist eine Textersetzung und das semicolon würde fehler beim einsetzen hervorrufen.
#define CURRENT_YEAR 2015;
// Selbiges wie aus der Zeile zuvor
#define MAX_YEAR 2500;


int main(int argc, char **argv){


    // year kann nicht in der for schleife definiert werden. Lösung: int year; for(year = 0;...
    // MAX_YEAR Rechtschreibfehler
    for(int year=0; year < MAX_YAER; year++){

        // == anstatt =. Das einfache = würde year neu zuweisen anstatt einen Vergleich durchzuführen
        // Semicolon muss entfernt werden. if-Body {} um printIt(year);
        if( year = CURRENT_YEAR );
            printIt(year);

        // else-body {} um printf(...) fehlt.
        else
            // semicolon hinter printf(...) fehlt
            printf("passed the year %d...", year)
    }

// Methode sollte vor der Main Methode stehen.
// int anstatt Int beim rückgabewert.
Int printIt(int year){
    printf("The current year is: %d", year);
}






b) 4 Fehler
//#include <stdio.h> fehlt. printf verursacht warning.
int main(int argc, char **argv){


    // Initialisierung der Variable value fehlt.
    int value;
    do{
        value++;
        printf("current value: %d", value);


    // Semicolon hinter while(...) fehlt
    // Anstatt !(value==10) wäre value!=10 besser zu lesen.
    }while(!(value==10) || !(value==20))
    //now our value equals 10
    return 0;
}






c) 6? Fehler


#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//input: single text argument
//output: text argument printed backwards
int main(int argc, char **argv){
    // argv[0] würde namen des programms zurückgeben und nicht das erste string argument
    // hier war wohl malloc(strlen(argv[1] * sizeof(char)) gemeint um einen buffer auf einen string zu bekommen
    char* buff = malloc(strlen(argv[0]));
    int i;
    //sizeof braucht einen datentypen. hier muss aber strlen(argv[1]) anstatt sizeof(...) hin um die länge des ersten arguments zu bekommen
    for(i=sizeof(argv[0]); i>=0; i--){
        // auch hier argv[1][i]
        // iwas mit der buff zählweise und rechnen mit pointern
        *buff++ = argv[0][i];
    }
    //buffer zeigt nicht auf das erste element des auszugebenen strings sondern auf das letzte. Lösung wäre ein 2. Pointer der am anfang von buff geklont wird
    // und dann für die pointer berechnungen aus den zeilen zuvor genutzt wird. dann zeigt buff immernoch auf den anfang des strings
    printf("%s\n", buff);
    // nur durch den 2. pointer aus der zeile drüber ist diese zeile korrekt
    free(buff);
    return 0;
}






d)
#include <stdio.h>

// rückgabe für array ist int* anstatt int[]
// int vector[] - eckige klammern hinter den variablen namen und nicht dem typen
int[] times(int[] vector, int times){
    int i;
    // for schleife würde durch sizeof vector zu weit laufen. der wert müsste noch durch size of int geteilt werden um die anzahl der elemente zu bekommen
    for(i=0; i<sizeof(vector); i++){
        vector[i] *= times;
    }
    return vector;
}

int main(int argc, char **argv){
    //auch hier int v[4]
    //v soll vermutlich vector heißen
    int[4] v = {1,1,1,1};
    vector = times(vector, 2);
    // auch hier wird mit v wohl vector gemeint sein
    printf("(%d,%d,%d,%d)", v[1],v[2],v[3],v[4]);
    return 0;
}


Aufgabe2:
a)
b)
c)
Der Aufruf gets() List solange ein, bis entweder EoF oder newline Eintritt.
Evtl. ist der String der eingelesen wird allerdings länger als die 64 Einträge,
die das Char Array zur Verfügung stellt.
d)
e)
f)
g)
h)
i)
j)


Aufgabe 3:
a) $ ps -e | grep foo
ps -e gibt eine Liste aller Prozesse aus die gerade laufen. Mit dem Zusatz grep
foo werden diese nach foo gefiltert. Man bekommt also alle Prozesse ausgegeben,
die foo im Namen tragen.

b) $ kill -9 3492
Killed (Beendet) den Prozess mit der Nummer 3492 sofort.

c) $ find . -name datei
Sucht im aktuellen Verzeichnis(signalisiert durch den Punkt) und den Unterverzeichnissen nach einer Datei oder einem Ordner mit dem Namen "datei".

d) $ top -n 10 -u root
top ist eine Art Taskmanager. Es zeigt die aktuell Laufenden Prozesse an und aktualisiert
sich dauerhaft automatisch. -u root beschränkt die angezeigten Prozesse auf den Nutzer
root.
Unsicher: Mit -n 10 läuft top nur bis man 10 mal refreshed hat?

e) $ cat -n test.txt
Zeigt die Datei test.txt auf der Commandozeile. -n Gibt Zeilenangaben vor jeder Zeile an

f) $ sudo chmod 734 HelloWorld
chmod ändert die Lese und Schreib Berechtigungen der Datei HelloWorld.
734 steht dabei für die Rechte die zugeilt werden sollen.
7 steht für rwx was bedeutet der Nutzer kann die Datei lesen, schreiben und ausführen.
3 steht für wx. Die Gruppe hat Schreib und Ausführrechte.
4 steht nur für w. Jede Person kann diese Person lesen.
sudo ist ein vorgeschaltetes Programm mit dem es möglich ist Programme als ein anderer
Nutzer auszuführen der zB mehr Rechte besitzt.

g) $ diff -q hello.txt bye.txt
Vergleicht beide Dateien und gibt an ob sie sich unterscheiden oder gleich sind.
Ohne das -q gibt es beide Dateien auf der Kommando Zeile aus.

h) $ tar cjvf foobar.tar.bz2 foobar
Tar comprimiert die Datei foobar zu foobar.tar.bz2
c wird mitgegeben um zu sagen das ein Archiv erstellt werden soll.
Durch j wird das bzip2 Verfahren genutzt.
v Gibt nochmal alle komprimierten Dateien auf der Kommandozeile aus.
f wird benötigt um den Dateinamen der Zieldatei mitzugeben.


i) $ du -hs .
du listet alle Dateien auf die sich im Verzeichnis (hier . Also da wo man sich befindet)
befinden mit ihren Größen auf. Durch -h werden die Dateigrößen in für Menschen lesbar
dargestellt (MB, KB etc.) und durch -s wird nur angezeigt wie viel Platz alle Dateien
zusammen einnehmen.

j) $ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-\
4.0.tar.xz; tar xJf linux-4.0.tar.xz; grep -R --\
include=*.[hcS] ' fuck\| shit' linux-4.0 | wc -l
Dieser Command besteht aus 3 Teilen.
1. wget downloadet die Datei des angegebenen Links.
2. tar linux-4.0.tar.xz entpackt diese dann.
3. grep durchsucht Archiv dann Rekursiv und mit alles symbolic links also Verknüpfungen nach
Dateien die die Dateiendung h, c oder S haben. Danach sucht es in den Dateien nach den
Wörtern 'fuck' und 'shit' und zählt mit wc -l die Zeilen in denen die Wörter vorkommen.
